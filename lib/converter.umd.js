!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports,require("bech32"),require("crypto-addr-codec")):"function"==typeof define&&define.amd?define(["exports","bech32","crypto-addr-codec"],r):r((e||self).atmostoeth={},e.bech32,e.cryptoAddrCodec)}(this,function(e,r,o){const t={decoder:e=>{const r=o.stripHexPrefix(e);if(!o.isValidChecksumAddress(e,null)&&r!==r.toLowerCase()&&r!==r.toUpperCase())throw Error("Invalid address checksum");return Buffer.from(o.stripHexPrefix(e),"hex")},encoder:e=>o.toChecksumAddress(e.toString("hex"),null),name:"ETH"};function d(e){return o=>r.encode(e,r.toWords(o))}const n=(e,o)=>{return{decoder:(t=o,e=>{const{prefix:o,words:d}=r.decode(e);if(o!==t)throw Error("Unrecognised address format");return Buffer.from(r.fromWords(d))}),encoder:d(o),name:e};var t},c=n("ETHERMINT","ethm"),s=n("ATMOS","atmos");e.ATMOS=s,e.ETH=t,e.ETHERMINT=c,e.Eip55ToBech32=(e,r,o)=>{let d=n(r,o),c=t.decoder(e);return d.encoder(c)},e.atmosToEth=e=>{let r=s.decoder(e);return t.encoder(r)},e.bech32ToEip55=(e,r,o)=>{let d=n(r,o).decoder(e);return t.encoder(d)},e.ethToAtmos=e=>{let r=t.decoder(e);return s.encoder(r)},e.ethToEthermint=e=>{let r=t.decoder(e);return c.encoder(r)},e.ethermintToEth=e=>{let r=c.decoder(e);return t.encoder(r)}});
//# sourceMappingURL=converter.umd.js.map
